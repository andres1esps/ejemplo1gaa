import os
from time import sleep
from datetime import datetime
#registro de jugadores y la carga del archivo
class GestionJugadores:
    def __init__(self):
        self.archivo_jugadores = "jugadores.txt"
        self.jugadores = {}
        self.cargar_jugadores()

    def cargar_jugadores(self):
        # Verifica si el archivo existe con utf-8
        if os.path.exists(self.archivo_jugadores):
            archivo = open(self.archivo_jugadores, 'r', encoding='utf-8')
            lineas = archivo.readlines()
            archivo.close()
            # crea los datos que son los registros de los logros del jugador
            for linea in lineas:
                datos = linea.strip().split('|')
                nombre = datos[0]
                self.jugadores[nombre] = {
                    "victorias": int(datos[1]),
                    "derrotas": int(datos[2]),
                    "empates": int(datos[3]),
                    "partidas_jugadas": int(datos[4]),
                    "fecha_registro": datos[5]
                }
        else:
            # Si el archivo no existe, crea uno vacio
            archivo = open(self.archivo_jugadores, 'w', encoding='utf-8')
            archivo.close()

    def guardar_jugadores(self):
        archivo = open(self.archivo_jugadores, 'w', encoding='utf-8')
        for nombre, stats in self.jugadores.items():
            linea = f"{nombre}|{stats['victorias']}|{stats['derrotas']}|{stats['empates']}|{stats['partidas_jugadas']}|{stats['fecha_registro']}\n"
            archivo.write(linea)
        archivo.close()

    def registrar_jugador(self, nombre):
        # Si el jugador no existe, lo registra
        if nombre not in self.jugadores:
            self.jugadores[nombre] = {
                "victorias": 0,
                "derrotas": 0,
                "empates": 0,
                "partidas_jugadas": 0,
                "fecha_registro": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            }
            self.guardar_jugadores()
            self.registrar_historial(f"Nuevo jugador registrado: {nombre}")
            return True
        return False
#registro del historial de jugadas, en tiempo y hora
    def registrar_historial(self, evento):
        archivo = open("historial.txt", 'a', encoding='utf-8')
        fecha = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        archivo.write(f"{fecha} - {evento}\n")
        archivo.close()

    def actualizar_estadisticas(self, jugador, resultado):
        if jugador in self.jugadores:
            self.jugadores[jugador]["partidas_jugadas"] += 1
            if resultado == "victoria":
                self.jugadores[jugador]["victorias"] += 1
                self.registrar_historial(f"{jugador} gano una partida")
            elif resultado == "derrota":
                self.jugadores[jugador]["derrotas"] += 1
                self.registrar_historial(f"{jugador} perdio una partida")
            else:
                self.jugadores[jugador]["empates"] += 1
                self.registrar_historial(f"{jugador} empato una partida")
            self.guardar_jugadores()
#busca un jugador por su nombre
    def buscar_jugador(self, nombre):
        if nombre in self.jugadores:
            return self.jugadores[nombre]
        return None

    def ordenar_jugadores_por_victorias(self):
        #convierte el diccionario a lista de tuplas
        jugadores_lista = []
        for nombre, stats in self.jugadores.items():
            jugadores_lista.append((nombre, stats))
        
        #Agregamos quicksort
        def quicksort(arr, low, high):
            def partition(arr, low, high):
                # Usa el ultimo elemento como pivote
                pivot = arr[high][1]['victorias']
                i = low - 1  #indice del elemento mÃ¡s pequeÃ±o
                
                for j in range(low, high):
                    #Si el elemento actual es mayor o igual que el pivote
                    #(ordenamiento descendente)
                    if arr[j][1]['victorias'] >= pivot:
                        i += 1
                        arr[i], arr[j] = arr[j], arr[i]
                
                arr[i + 1], arr[high] = arr[high], arr[i + 1]
                return i + 1
            
            if low < high:
                #pi es el indice de particiÃ³n
                pi = partition(arr, low, high)
                
                #Ordena los elementos antes y despues de la particion
                quicksort(arr, low, pi - 1)
                quicksort(arr, pi + 1, high)
        
        # Llamamos al quicksort con la lista completa
        if len(jugadores_lista) > 0:
            quicksort(jugadores_lista, 0, len(jugadores_lista) - 1)
        
        return jugadores_lista
#ranking de los jugadores y sus estadisticas
    def mostrar_ranking(self):
        print("\n=== RANKING DE JUGADORES ===")
        jugadores_ordenados = self.ordenar_jugadores_por_victorias()
        posicion = 1
        for nombre, stats in jugadores_ordenados:
            print(f"\n{posicion}. {nombre}")
            print(f"   Victorias: {stats['victorias']}")
            print(f"   Derrotas: {stats['derrotas']}")
            print(f"   Empates: {stats['empates']}")
            print(f"   Total partidas: {stats['partidas_jugadas']}")
            print(f"   Fecha de registro: {stats['fecha_registro']}")
            posicion += 1
#muestra los eventos que se hicieron guardados en el historial
    def mostrar_historial(self):
        print("\n=== ðŸ“œ HISTORIAL DE EVENTOS ðŸ“œ ===")
        if os.path.exists("historial.txt"):
            archivo = open("historial.txt", 'r', encoding='utf-8')
            eventos = archivo.readlines()
            archivo.close()
            
            if len(eventos) == 0:
                print("No hay eventos registrados")
            else:
                # Muestra solo los ultimos 10 eventos
                ultimos_eventos = eventos[-10:]
                for evento in ultimos_eventos:
                    print(evento.strip())
        else:
            print("No hay historial disponible.")#como no hay un historial que haya registrado jugadores
#otro registro de jugadores, la parte logica del tres en raya
class TresEnRaya:
    def __init__(self):
        self.tablero = [" ", " ", " ", " ", " ", " ", " ", " ", " "]
        self.gestion_jugadores = GestionJugadores()
        self.combinaciones_ganadoras = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8],  # horizontales
            [0, 3, 6], [1, 4, 7], [2, 5, 8],  # verticales
            [0, 4, 8], [2, 4, 6]              # diagonales
        ]
        self.jugador_x = None
        self.jugador_o = None
#menu 
    def menu_principal(self):
        seguir_jugando = True
        while seguir_jugando:
            self.limpiar_pantalla()
            print("\n=== MENU PRINCIPAL ===")
            print("1. iniciar nueva partida")
            print("2. ver ranking de jugadores")
            print("3. buscar estadÃ­sticas de jugador")
            print("4. ver historial de eventos")
            print("5. salir")
            
            opcion = input("\nSeleccione un numero o opcion: ")
            
            if opcion == "1":
                self.preparar_partida()
            elif opcion == "2":
                self.gestion_jugadores.mostrar_ranking()
                input("\nPresione Enter para continuar")
            elif opcion == "3":
                self.buscar_estadisticas_jugador()
            elif opcion == "4":
                self.gestion_jugadores.mostrar_historial()
                input("\nPresione Enter para continuar")
            elif opcion == "5":
                print("\nÂ¡Muchas gracias por jugar")
                seguir_jugando = False

    def buscar_estadisticas_jugador(self):
        nombre = input("\nIngrese el nombre del jugador a buscar: ")
        datos_jugador = self.gestion_jugadores.buscar_jugador(nombre)
        if datos_jugador is not None:
            print(f"\nEstadÃ­sticas de {nombre}:")
            print(f"Victorias: {datos_jugador['victorias']}")
            print(f"Derrotas: {datos_jugador['derrotas']}")
            print(f"Empates: {datos_jugador['empates']}")
            print(f"Total partidas: {datos_jugador['partidas_jugadas']}")
            print(f"Fecha de registro: {datos_jugador['fecha_registro']}")
        else:
            print("\nJugador no encontrado")
        input("\nPresione Enter para continuar")

    def preparar_partida(self):
        self.limpiar_pantalla()
        print("\n=== REGISTRO DE JUGADORES ===")
        
        # Registro jugador X
        self.jugador_x = ""
        while self.jugador_x == "":
            self.jugador_x = input("\nNombre del Jugador X ")
            if self.jugador_x == "":
                print("Tienes que poner un nombre en el espacio")
        
        self.gestion_jugadores.registrar_jugador(self.jugador_x)
        
        # Registro jugador O
        self.jugador_o = ""
        while self.jugador_o == "" or self.jugador_o == self.jugador_x:
            self.jugador_o = input("Nombre del Jugador O: ")
            if self.jugador_o == "":
                print("El nombre no puede estar vacio")
            elif self.jugador_o == self.jugador_x:
                print("Debe ser diferente al Jugador X")
        
        self.gestion_jugadores.registrar_jugador(self.jugador_o)
        
        # Iniciar tablero vacIo
        self.tablero = [" " for _ in range(9)]
        self.jugar()

    def limpiar_pantalla(self):
        if os.name == 'nt':  # Para Windows
            os.system('cls')
        else:  # Para Unix/Linux/MacOS
            os.system('clear')

    def imprimir_tablero(self):
        self.limpiar_pantalla()
        print(f"\n ___BIENVENIDO AL TRES EN RAYA____")
        print(f"Jugador X: {self.jugador_x}")
        print(f"Jugador O: {self.jugador_o}\n")
        print(" La referencia:")
        print(" 1 | 2 | 3    ", f" {self.tablero[0]} | {self.tablero[1]} | {self.tablero[2]} ")
        print("-----------    -----------")
        print(" 4 | 5 | 6    ", f" {self.tablero[3]} | {self.tablero[4]} | {self.tablero[5]} ")
        print("-----------    -----------")
        print(" 7 | 8 | 9    ", f" {self.tablero[6]} | {self.tablero[7]} | {self.tablero[8]} ")
        print("\n")

    def hay_ganador(self, jugador):
        for combinacion in self.combinaciones_ganadoras:
            if (self.tablero[combinacion[0]] == jugador and 
                self.tablero[combinacion[1]] == jugador and 
                self.tablero[combinacion[2]] == jugador):
                return True
        return False

    def es_empate(self):
        for casilla in self.tablero:
            if casilla == " ":
                return False
        return True

    def movimiento_valido(self, posicion):
        if not posicion.isdigit():
            return False
        posicion = int(posicion)
        if posicion < 1 or posicion > 9:
            return False
        if self.tablero[posicion - 1] != " ":
            return False
        return True

    def jugar(self):
        jugador_actual = "X"
        jugando = True
        
        while jugando:
            self.imprimir_tablero()
            nombre_jugador_actual = self.jugador_x if jugador_actual == "X" else self.jugador_o
            
            movimiento_realizado = False
            while not movimiento_realizado:
                movimiento = input(f"\nJugador {jugador_actual} ({nombre_jugador_actual}), "
                                 f"elige un espacio (1-9) o 'q' para salir: ")
                
                if movimiento.lower() == 'q':
                    return
                
                if self.movimiento_valido(movimiento):
                    movimiento = int(movimiento) - 1
                    self.tablero[movimiento] = jugador_actual
                    movimiento_realizado = True
                else:
                    print("\nMovimiento no valido. Vuelve a intentar otro movimiento")
                    sleep(1)
            
            if self.hay_ganador(jugador_actual):
                self.imprimir_tablero()
                ganador = self.jugador_x if jugador_actual == "X" else self.jugador_o
                perdedor = self.jugador_o if jugador_actual == "X" else self.jugador_x
                print(f"Â¡{ganador} gano")
                self.gestion_jugadores.actualizar_estadisticas(ganador, "victoria")
                self.gestion_jugadores.actualizar_estadisticas(perdedor, "derrota")
                jugando = False
            elif self.es_empate():
                self.imprimir_tablero()
                print("Hubo un empate")
                self.gestion_jugadores.actualizar_estadisticas(self.jugador_x, "empate")
                self.gestion_jugadores.actualizar_estadisticas(self.jugador_o, "empate")
                jugando = False
            else:
                jugador_actual = "O" if jugador_actual == "X" else "X"

        input("\nPresione enter para continuar")

if __name__ == "__main__":
    juego = TresEnRaya()
    juego.menu_principal()